substitutions:
  device_name: taubenfutterspender
  device_friendly_name: Taubenfutterspender
  device_area: Hof

  status_led_pin: GPIO2


packages:
  system: !include system/stamp_c3u.yaml
  wifi: !include common/wifi.yaml
  general: !include common/general.yaml
  status_led: !include include/on_board_status_led_sk6812.yaml


# wifi:
#   use_address: 192.168.23.106


esphome:
  on_boot:
    - priority: -10
      then:
        - servo.detach: servo_motor
        - binary_sensor.template.publish:
            id: sensor_servo_motor_active
            state: OFF
        - sensor.template.publish:
            id: sensor_output_total_g
            state: 0


time:
  - platform: homeassistant
    id: homeassistant_time


# https://esphome.io/components/output/ledc
output:
  - platform: ledc
    pin: GPIO10
    id: servo_pwm
    frequency: 50 Hz


# https://esphome.io/components/servo.html
# Turnigy TGY-SM-4309R https://hobbyking.com/en_us/turnigy-tgy-sm-4309r-360-analog-metal-gear-robot-servo-8-7kg-57rpm-56g.html
# http://rcsearch.info/hobbyking/i41212/#catalog
servo:
  - id: servo_motor
    output: servo_pwm
    #min_level: 5.75%
    min_level: 7.25%  # Disallow backwards rotation
    idle_level: 7.25%
    max_level: 8.75%
    restore: false
    transition_length: 500ms


globals:
  - id: global_output_target_corr_g
    type: int
    restore_value: no
    initial_value: '-1.0'

  - id: global_storage_remaining_before_last_run_g
    type: int
    restore_value: no
    initial_value: '0.0'

  - id: global_dt_last_run_start
    type: long int
    restore_value: no

  - id: global_dt_last_run_stop
    type: long int
    restore_value: no


sensor:
  - platform: template
    name: Progress
    id: sensor_output_progress_pct
    icon: mdi:progress-helper
    unit_of_measurement: '%'
    accuracy_decimals: 0

  - platform: template
    name: Last run datetime
    id: sensor_last_run_dt
    icon: mdi:timer-outline
    device_class: timestamp

  - platform: template
    name: Last run duration
    id: sensor_last_run_seconds
    icon: mdi:timer-cog-outline
    unit_of_measurement: s

  - platform: template
    name: Last run output
    id: sensor_last_run_output_g
    icon: mdi:scale
    device_class: weight
    unit_of_measurement: g
    accuracy_decimals: 0

  - platform: template
    name: Last run speed
    id: sensor_last_run_speed_gps
    icon: mdi:speedometer
    unit_of_measurement: 'g/s'

  - platform: template
    name: Total output
    id: sensor_output_total_g
    icon: mdi:scale
    state_class: total
    device_class: weight
    unit_of_measurement: g
    accuracy_decimals: 0

  - platform: hx711
    name: Storage
    id: sensor_storage_remaining_g
    dout_pin: GPIO7
    clk_pin: GPIO8
    update_interval: 250ms
    filters:
      - median:
          window_size: 3
          send_every: 1
      - calibrate_linear:
          # Attention: These need to be set once per new load cell
          - 90000 -> 0
          - 608000 -> 5000
      - lambda: if (x < 0.0 & x > -300.0) return 0.0; else return x;
      - delta: 25
    icon: mdi:beer-outline
    device_class: weight
    unit_of_measurement: g
    accuracy_decimals: 0
    on_value:
      then:
        - sensor.template.publish:
            id: sensor_output_progress_pct
            # Publish output progress in 0..100%, and 'unknown' in-between runs
            state: !lambda |-
              if (id(global_output_target_corr_g) < 0) {
                return NAN;
              } else {
                return 100.0 / id(global_output_target_corr_g) * (id(global_storage_remaining_before_last_run_g) - x);
              }


binary_sensor:
  - platform: template
    name: Dispenser motor active
    id: sensor_servo_motor_active

  - platform: gpio
    name: Case button and on-board button
    internal: true
    pin:
      number: GPIO9
      inverted: true
    filters:
      - delayed_on: 50ms
    on_press:
      then:
        - script.execute:
            id: script_controlled_output
            timeout_sec: 8
            target_g: 9999
            offset_g: 0


script:
  - id: script_controlled_output
    mode: single

    parameters:
      timeout_sec: int
      target_g: int
      offset_g: int

    then:

      # Check inputs and fail if no output possible
      - if:
          condition:
            lambda: |-
              return (timeout_sec <= 0) | (target_g - offset_g <= 0);
          then:
            - logger.log: "Cancelling 'script_controlled_output' due to parameters given."
            - script.stop: script_controlled_output

      # Indicate the beginning of the output process
      - light.turn_on:
          id: on_board_led
          red: 60%
          green: 50%
          blue: 0%
          brightness: 100%
          transition_length: 500ms
      - binary_sensor.template.publish:
          id: sensor_servo_motor_active
          state: ON
      - logger.log:
          format: "Output started. Remaining in storage = %dg; target output = %dg; offset = %dg"
          args: [ 'id(sensor_storage_remaining_g).state', 'target_g', 'offset_g' ]

      # Publish clean starting values
      - sensor.template.publish:
          id: sensor_output_progress_pct
          state: 0.0
      - sensor.template.publish:
          id: sensor_last_run_output_g
          state: 0.0

      # Buffer relevant values
      - globals.set:
          id: global_storage_remaining_before_last_run_g
          value: !lambda |-
            return id(sensor_storage_remaining_g).state;
      - globals.set:
          id: global_output_target_corr_g
          value: !lambda |-
            return target_g - offset_g;

      # Run servo motor until output target or timeout reached
      - globals.set:
          id: global_dt_last_run_start
          value: !lambda |-
            return id(homeassistant_time).now().timestamp;
      - servo.write:
          id: servo_motor
          level: 100%
      - wait_until:
          condition:
            lambda: |-
              return (id(global_storage_remaining_before_last_run_g) - id(sensor_storage_remaining_g).state) >= id(global_output_target_corr_g);
          timeout: !lambda |-
            return timeout_sec * 1000.0;
      - servo.write:
          id: servo_motor
          level: 0%
      - globals.set:
          id: global_dt_last_run_stop
          value: !lambda |-
            return id(homeassistant_time).now().timestamp;

      # Give the process some time to settle
      - delay: 5s
      - servo.detach: servo_motor

      # Publish all sensor values
      - sensor.template.publish:
          id: sensor_last_run_dt
          state: !lambda |-
            return id(global_dt_last_run_stop);
      - sensor.template.publish:
          id: sensor_last_run_seconds
          state: !lambda |-
            return difftime(id(global_dt_last_run_stop), id(global_dt_last_run_start));
      - sensor.template.publish:
          id: sensor_last_run_output_g
          state: !lambda |-
            return id(global_storage_remaining_before_last_run_g) - id(sensor_storage_remaining_g).state;
      - sensor.template.publish:
          id: sensor_output_total_g
          state: !lambda |-
            return id(sensor_output_total_g).state + id(sensor_last_run_output_g).state;
      - sensor.template.publish:
          id: sensor_last_run_speed_gps
          state: !lambda |-
            return 1.0 * id(sensor_last_run_output_g).state / id(sensor_last_run_seconds).state;

      # Clean-up
      # Prevent unnecessary updates of 'sensor_output_progress_pct' and publish 'unknown' in-between runs
      - globals.set:
          id: global_output_target_corr_g
          value: '-1.0'

      # Indicate the end of the output process
      - logger.log:
          format: "Output finished. Remaining in storage = %dg; output = %dg; duration = %ds"
          args: [ 'id(sensor_storage_remaining_g).state', 'id(sensor_last_run_output_g).state', 'id(sensor_last_run_seconds).state' ]
      - binary_sensor.template.publish:
          id: sensor_servo_motor_active
          state: OFF
      - light.turn_off:
          id: on_board_led
          transition_length: 500ms


api:
  services:
    #
    # Home Assistant Service
    #
    # timeout_sec: Max duration in seconds to prevent damages in case of clogging or similar.
    # You should choose a meaningful timeout (e.g. 2x normal duration) to act as a safeguard in case of issues.
    #
    # target_g: Output target mass. Expect the result to slightly overshoot (see offset_g).
    # Set to 9999 if you want to work with a fixed duration via timeout_sec.
    #
    # offset_g: Correction to the provided target output to prevent overshooting.
    # You have to identify this value over the course of a few trial runs.
    # Internal target = target_g - offset_g
    #
    - service: output
      variables:
        timeout_sec: int
        target_g: int
        offset_g: int
      then:
        - script.execute:
            id: script_controlled_output
            timeout_sec: !lambda 'return timeout_sec;'
            target_g: !lambda 'return target_g;'
            offset_g: !lambda 'return offset_g;'


number:
  - platform: template
    name: Manual motor control
    entity_category: "diagnostic"
    icon: mdi:screw-round-top
    mode: slider
    min_value: 0
    max_value: 100
    initial_value: 0
    step: 1
    optimistic: false
    set_action:
      then:
        - if:
            condition:
              lambda: 'return x > 0;'
            then:
              - servo.write:
                  id: servo_motor
                  level: !lambda 'return x / 100.0;'
            else:
              - servo.detach: servo_motor


button:
  - platform: template
    name: Emergency stop
    on_press:
      - script.stop: script_controlled_output
      - servo.write:
          id: servo_motor
          level: 0%
      - servo.detach: servo_motor
      - light.turn_off: on_board_led
      - binary_sensor.template.publish:
          id: sensor_servo_motor_active
          state: OFF
